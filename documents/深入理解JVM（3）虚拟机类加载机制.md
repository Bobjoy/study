# <center>深入理解JVM（3） : 虚拟机类加载机制</center>

#### **一、基本概念**
***
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

与那些在编译时需要进行链接工作的语言不同，在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java可以动态扩展的语言特性就是依赖运行期间动态加载和动态链接这个特点实现的。

**类的生命周期：**

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。
<center>![类的生命周期](file:///D:/Bao/Pictures/blog/leideshengmingzhouqi.jpg "类的生命周期")</center>

这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另一个阶段。
例如：加载阶段与连接阶段的部分内容（如一部分字节码的文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

#### **二、类加载的时机**
---
Java虚拟机规范没有强制性约束在什么时候开始类加载过程，但是对于初始化阶段，虚拟机规范则严格规定了有且只有5种情况必需立即对类进行“初始化”（而加载、验证、准备阶段自然需要在此之前开始）。

1. 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或者设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）时、以及调用一个类的静态方法的时候。

2. 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()`方法的那个类），虚拟机会先初始化这个类。

5. 当使用JDK1.7的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果  `REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

对于这5种会触发类进行初始化的场景，在java虚拟机规范中限定了“有且只有”这5种场景会触发。
这5种场景中的行为称为对一个类的主动引用，除此以外的所有引用类的方式都不会触发类的初始化，称为被动引用。

##### 被动引用示例：

1. 通过子类引用父类的静态字段，不会导致子类初始化。
    ```java
    public class SuperClass {  
        static{  
            System.out.println("SuperClass init!");  
        }  
        public static int value = 123;  
    }
    public class SubClass extends SuperClass {  
        static{
            System.out.println("SubClass init!");  
        }
    }
    public class NotInitialization {  
        public static void main(String[] args) {  
            System.out.println(SubClass.value);  
        }  
    }
    SuperClass init!  
    123
    ```
    
    对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

2. 通过数组定义来引用类，不会触发此类的初始化。
    ```java
    public class SuperClass {  
        static{  
            System.out.println("SuperClass init!");  
        }  
        public static int value = 123;  
    }  
    public class NotInitialization {  
        public static void main(String[] args) {  
            SuperClass[] scs = new SuperClass[10];  
        }  
    }
    ```
    输出结果为空
    
    没有输出`SuperClass init`！说明没有触发类`com.zm.classloading.SuperClass`的初始化阶段，但是这段代码会触发`[Lcom.zm.classloading.SuperClas`s类的初始化阶段。这个类是由虚拟机自动生成的，直接继承于`java.lang.Object`的子类，创建动作由字节码指令 `newarray`触发。

3. 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
    ```java
    public class ConstClass {
        static{
            System.out.println("ConstClass init!");
        }
        public static final String HELLOWORLD = "hello world";
    }
    public class NotInitialization {
        public static void main(String[] args) {
            System.out.println(ConstClass.HELLOWORLD);
        }
    }
    hello world
    ```
    
    虽然在Java源码中引用了ConstClass类中的常量`HELLOWORLD`，但其实在编译阶段通过常量传播优化，已经将此常量的值`hello world`存储到`NotInitialization类的常量池中，以后NotInitialization对于常量`ConstClass.HELLOWORLD`的引用实际上都被转化为NotInitialization类对自身常量池的引用了。实际上NotInitialization的Class文件之中已经不存在ConstClass类的符号引用入口了。

##### 接口的加载过程：

接口也有初始化过程，这与类是一致的，上述的代码中都是使用静态语句块`static{}`来输出初始化信息的，而接口中不能使用`static{}`语句块，但编译器仍然会为接口生成`<clinit>()`类构造器，用于初始化接口中所定义的成员变量。

接口的加载过程与类加载的区别在于上面提到的5种“有且仅有”需要初始化场景中的第3种：当一个类在初始化时要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口都全部完成了初始化，只有在真正用到父接口的时候（如引用父接口中定义的常量）才会初始化。

#### **三、类加载的过程**
***
下面我们来详细了解类加载的全过程，也就是加载、验证、准备、解析和初始化这五个阶段的过程。


1. **加载**

    首先要说明的是“加载”（Loading）阶段只是“类加载”（Class Loading）过程的一个阶段。不要混淆了这两个概念。在加载阶段，虚拟机需要完成以下三件事情：

    1）通过一个类的全限定名来获取定义此类的二进制字节流。
    
    2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    
    3）在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类各种数据的访问入口。

    相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确的说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为该阶段既可以使用系统提供的引导类加载器完成，也可以由用户自定义的类加载器来完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。

    对于数组类而言，数组类本身不通过类加载器创建，它是由虚拟机直接创建的。但是数组类的元数据类型最终还是要靠类加载器去创建的。

    加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由JVM自行定义。然后在内存中实例化一个`java.lang.Class`对象，这个对象将作为程序访问方法区中这些类型数据的外部接口。（对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面）


2. **验证**

    验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
    
    整体上看，验证阶段会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。
    + 1）文件格式验证：这一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。  
        * 是否以魔术0xCAFEBABE开头；
        * 主次版本号是否是在当前虚拟机处理范围之内；
        * 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）；  
        . . .
        
        第一阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合一个Java类型信息的要求。
    
        这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。
    + 2）元数据验证：这一阶段主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。
        * 这个类是否有父类；
        * 这个类的父类是否继承了不允许被继承的类（被final修饰的类）；
        * 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法；
        * 类中的字段、方法是否与父类产生矛盾（如覆盖了父类的final字段，不符合规则的重载）；  
            . . .
        
        第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java规范的元数据类型。
    + 3）字节码验证：这一阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
    
        在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析。保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
        * 保证跳转指令不会跳转到方法体之外的字节码指令上；
        * 保证方法体中的类型转换是有效的，例如将子类对象赋给父类对象是安全的，但是把父类对象赋值给子类数据类型，甚至是和它毫无继承关系的一个数据类型，则是危险和不安全的；
        * 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现在操作数栈中放置了一个int类型数据，使用时却按long类型来加载人本地变量表中。  
            . . .
    + 4）符号引用验证：这一阶段主要是在虚拟机将符号引用转化为直接引用的时候进行校验，这个转化动作是发生在解析阶段。符号引用可以看做是对类自身以外（常量池的各种符号引用）的信息进行匹配性的校验。
        * 符号引用中通过字符串描述的全限定名是否能找到相应的类；
        * 在指定类中是否存在符合方法的字段描述符以及简单名称所描述方法和字段；
        * 符号引用中的类、字段、方法的访问性（`private、public、protected、default`）是否可以被当前类访问；  
            . . .
            
        符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出异常。

    验证阶段对于虚拟机的类加载机制来说，是一个非常重要但不一定是必要的阶段。如果所运行的全部代码都已经被反复使用和验证过，在实施阶段就可以考虑使用`-Xverify:none`参数来关闭大部分的类验证措施，从而缩短虚拟机类加载的时间。


3. **准备**

    准备阶段是正式为**类变量**分配内存并设置**类变量初始值**的阶段，这些内存都将在方法区中进行分配。
    + 这个时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起被分配在Java堆中。
    + 这里所说的初始值“通常情况”下是数据类型的零值，例如`public static int value = 123 ；`value在准备阶段后的初始值是0而不是123，因为此时尚未执行任何的Java方法，而把value赋值为123的putStatic指令是程序被编译后，存放在类构造器<clinit>()方法之中，把value赋值为123的动作将在初始化阶段才会执行。
    + 通常情况下初始值为零值，相对的会存在特殊情况：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量就会被初始化为ConstantValue属性所指定的值，例如`public static final int value = 123` 编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将变量赋值为123。


4. **解析**

    解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
    
    在Class文件中符号引用以`CONSTANT_Class_info`、`CONSTANT_Fieldref_info`、`CONSTANT_Methodref_info`等类型的常量出现。
    + **符号引用**（Symbolic Reference）：  
        符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载在内存中。各种虚拟机实现的内存布局可以各不相同，但是他们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。
    + **直接引用**（Direct Reference）：  
        直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。
        
    对于同一个符号引用可能会出现多次解析请求，虚拟机可能会对第一次解析的结果进行缓存。
    
    解析动作主要针对：类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

    个人理解：一个java类将会编译成一个class文件。在编译时，java类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。比如org.simple.People类引用org.simple.Tool类，在编译时People类并不知道Tool类的实际内存地址，因此只能使用符号org.simple.Tool(假设)来表示Tool类的地址。而在类加载器加载People类时，此时可以通过虚拟机获取Tool类的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。


5. **初始化**

    类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。

    初始化阶段是执行类构造器`<clinit>()`方法的过程。对于`<clinit>()`方法具体介绍如下：
    + (1)`<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（`static{}`块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序所决定。
    
       静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，**在前面的静态语句块可以赋值，但是不能访问。**
    ```java
    public class Test {
        static{
            i =0;          /* 给变量赋值可以正常编译通过 */
            //System.out.println(i);  //这句编译器会提示“非法向前引用”
        }
        static int i = 1;
    }
    ```
    + (2)`<clinit>()`方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕，因此在虚拟机中第一个执行的`<clinit>()`方法的类一定是`java.lang.Object`。
    + (3) 由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下面的例子所示，输出结果为2而不是1。
    ```java
    public class Parent {  
        public static int A = 1;  
        static{  
           A = 2;  
        }  
    }    
    public class Sub extends Parent{  
        public static int B = A;  
    }   
    public class Test {  
        public static void main(String[] args) {  
           System.out.println(Sub.B);  
        }  
    }
    ```
    + (4)`<clinit>()`方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。
    + (5) 接口中不能使用静态语句块，但仍然有变量赋值的初始化操作，因此接口也会生成`<clinit>()`方法。但是接口与类不同，执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也不会执行接口的`<clinit>()`方法。
    + (6) 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁和同步。如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的`<clinit>()`方法，其它线程都需要阻塞等待，直到活动线程执行`<clinit>()`方法完毕。如果在一个类的`<clinit>()`方法中有耗时很长的操作，那么就可能造成多个进程阻塞。

    虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
